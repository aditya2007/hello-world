package com.java.core.companies.Microsoft;

import java.util.*;
import java.util.stream.Collectors;

public class OTSQuestions {

	private static final String TEST_TENANT = "f743b7ef-42df-4d7e-89dd-90dc3b53b0ac";
	private static final String TEST_EVENT = "a83d1532-eacf-455c-8200-6a245a820010";

	public static void main(String[] args) {
		OTSQuestions ots = new OTSQuestions();
		//Microsoft questionaries
		//generateRevFibSeries(80, 50);
		//System.out.println(generateLowestNumber("216504", 3));
		//makeTheNumbersMatch(5, 5, 10, 12);

		//Proofpoint Questionaries
		/*String sourceStr = "google";
		String[] checkingWords = {"goe", "geo", "get", "goo", "gog", "go", "gt"};
		for (String wordToCheck : checkingWords) {
			System.out.println(sourceStr + " contains seq characters of " + wordToCheck + " is :: "
					+ containsCharsInOrder(sourceStr, wordToCheck));
		}*/

		// Roche test
		int[] prices = {5,6,10,20};
		//int[] prices = {5,3,10,20};
		//int[] prices = {20,10,6};


		System.out.println(calculateLargestProfit1(prices));
		//calculateLargestProfit(); //stock overflow

		//int[] values = {2,3,1,1,4}; // Ans : 2
		//int[] values = new int[]{1,2,0,3,1,0};
		int[] values = new int[]{1,1,1,1,1,1}; // Ans : 5
		//int[] values = new int[]{1,1,1,1,1,0}; // Ans : 5
		//int[] values = new int[]{1,1,0,1,1,0}; // Ans : 3
		//int[] values = new int[]{1,2,1,3,1,0}; // Ans : 3
		//System.out.println(canJump(values));
		//findMinAndMax();
	}


	/**
	 * Microsoft OTS question
	 * You are tasked with implementing a method that returns the lowest possible number
	 * that could be generated after removing n characters from a string of digits.
	 * The method signature should look like:
	 *
	 * public static string GenerateLowestNumber(string number, int n)
	 * Where the number parameter is a string that contains a number (e.g. “4205123”),
	 * and the n parameter represents the number of characters to remove from the string.
	 * The goal of this method is to return the lowest number that can be generated by removing
	 * n characters from the number provided while keeping the positions of the remaining characters
	 * relative to each other the same (i.e. the method should remove n characters from the string,
	 * but it cannot re-order the characters).
	 * For example, if number is “4205123” and n is 4, the lowest possible number that can be generated
	 * after removing any 4 characters is “012”. If number is “216504” and n is 3, the lowest possible
	 * number that can be generated after removing 3 characters is “104”.
	 */
	static String generateLowestNumber(String str, int num) {
		if(num == 0) {
			return str;
		}

		int index = str.length() -1;
		for(int i=0; i< str.length() -1; i++) {
			if(getNum(str,i) > getNum(str, i+1)) {
				index = i;
				break;
			}
		}

		String newStr = str.substring(0, index);
		if(index < str.length() - 2) {
			newStr += str.substring(index+1);
		}
		return generateLowestNumber(newStr, num -1);
	}

	static int getNum(final String str, final int index) {
		//return Character.getNumericValue(str.charAt(index));
		return str.charAt(index) - '0';
	}

	/**
	 * Microsoft OTS question
	 * Given a 2 numbers, generate a reverse fibonacci.
	 * Example : 80, 50, 30, 20, 10, 10, 0
	 * @param x
	 * @param y
	 */
	private static void generateRevFibSeries(int x, int y) {
		if (x <= 0 || y <= 0) return;
		int next = x - y;
		int prev = y;
		StringBuilder builder = new StringBuilder();
		builder.append(x).append(",").append(y).append(",");

		while ( next > 0 ) {
			builder.append(next).append(",");
			int temp = next;
			next = prev - next;
			prev = temp;
		}
		builder.append(next);

		System.out.println(builder);
	}

	/**
	 * Increment/Decrement numbers A & B unitl matches to X & Y. Find the bug in the code
	 * @param a
	 * @param b
	 * @param x
	 * @param y
	 */
	private static void makeTheNumbersMatch(int a, int b, int x, int y) {
		// Given code
		/*while( a != x && b != y) {
			System.out.println("a : " + a + ", b : " + b);
			if (a > x) { //correct Here
				a++;
			} else {
				a--;
			}

			if ( b > y) { // Correct here
				b++;
			} else {
				b--;
			}
		}*/

		// Modified code
		while( a != x || b != y) {
			System.out.println("a : " + a + ", b : " + b);
			if (a < x) {
				a++;
			} else if (a > x){
				a--;
			}

			if ( b < y) {
				b++;
			} else if (b > y){
				b--;
			}
		}

	}

	/**
	 * ProofPoint
	 * Give a 2 Strings check whether, the 2nd string chars contain in the first string in order
	 * Example :
	 * i/p             o/p
	 * ====================
	 * google  goe     true
	 * google  geo     false
	 * google  get     false
	 * google  goo     true
	 * google  gog     true
	 * google  go      true
	 * google  gt      false
	 *
	 * @param sourceStr
	 * @param findStr
	 * @return
	 */
	static boolean containsCharsInOrder(String sourceStr, String findStr) {
		/*Map<Character, Integer> map = new HashMap<>();
		for (char ch2 : findStr.toCharArray()) {
			if (sourceStr.contains(ch2 + "")) {
				int pos = sourceStr.indexOf(ch2);
				if (map.containsKey(ch2)) {
					pos = sourceStr.indexOf(ch2, pos + 1);
				}
				map.put(ch2, pos);
				//sourceStr = sourceStr.substring(sourceStr.indexOf(ch2) + 1);
			}
		}
		if (map.size() < findStr.length()) return false;

		for (int idx = 0; idx < findStr.length() - 1; idx++) {
			if (map.get(findStr.charAt(idx)) > map.get(findStr.charAt(idx + 1))) return false;
		}*/

		int currPos = 0;
		int prvPos = -1;
		List<Character> list = new ArrayList<>();
		for (char ch2 : findStr.toCharArray()) {
			if (sourceStr.indexOf(ch2) >= 0) {
				if (list.contains(ch2)) {
					currPos = sourceStr.indexOf(ch2, prvPos + 1);
				} else {
					currPos = sourceStr.indexOf(ch2);
				}
				if (currPos < prvPos) return false;
				list.add(ch2);
				prvPos = currPos;
			} else {
				return false;
			}
		}
		return true;
	}

	/**
	 * Roche
	 * Given chronological stock prices at given times, find the largest profits
	 *
	 * Example :
	 * input : int[] prices = [5,6,10,20];
	 * output : 15
	 * input : int[] prices = [5,3,10,20];
	 * output : 17
	 * input : int[] prices = [20,10,6];
	 * output : 10
	 *
	 * This is my solution works fine for all condition in O(n2)
	 *
	 * For O(n) solution, check this
	 * https://stackoverflow.com/questions/7086464/maximum-single-sell-profit
	 *
	 * My approach
	 */
	static int calculateLargestProfit(int[] prices) {
		int largestProfit = 0;
		/*for (int i = 0; i < prices.length - 1; i++) {
			for (int j = 0; j < prices.length; j++) {
				int profit = prices[j] - prices[i];
				if (profit > largestProfit) {
					largestProfit = profit;
				}
			}
		}*/
		for (int i = 0; i < prices.length - 1; i++) {
			int temp = prices[i] - prices[i+1];
			if (temp > largestProfit) {
				largestProfit = temp;
			}
		}
		return largestProfit;
	}

	/**
	 * From Satckflow
	 * @param prices
	 */
	static int calculateLargestProfit1(int[] prices) {
		int min = prices[0]; // Lets assume first element is minimum
		int maxProfit = 0; // 0 profit, if we buy & sell on same day.
		int profit = 0;
		int minIndex = 0; // Index of buy date
		int maxIndex = 0; // Index of sell date

		//Run the loop from next element
		for (int i = 1; i < prices.length; i++) {
			//Keep track of minimum buy price & index
			if (prices[i] < min) {
				min = prices[i];
				minIndex = i;
			}
			if (prices[i] > min) {
				profit = prices[i] - min;
			} else {
				profit = min;
			}

			//If new profit is more than previous profit, keep it and update the max index
			if (profit > maxProfit) {
				maxProfit = profit;
				maxIndex = i;
			}
		}
//		System.out.println("maxProfit is "+maxProfit);
//		System.out.println("minIndex is "+minIndex);
//		System.out.println("maxIndex is "+maxIndex);
		return maxProfit;
	}

	/**
	 * eBay
	 *
	 * Given an array of non-negative integers, you are initially positioned at the first index of the array.
	 * Each element in the array represents your maximum jump length at that position.
	 * Your goal is to reach the last index in the minimum number of jumps.
		 For example:
			 Given array nums = [2,3,1,1,4] // Ans  : 3
	 int[] values = new int[]{1,1,1,1,1,1}; // Ans : 5
	 //int[] values = new int[]{1,1,1,1,1,0}; // Ans : 5
	 //int[] values = new int[]{1,1,0,1,1,0}; // Ans : 3
	 //int[] values = new int[]{1,2,1,3,1,0}; // Ans : 3


	 * The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1,
	 	then 3 steps to the last index.)
	 */
	static int canJump(int[] nums) {
		int stepCount = 0;
		int prevJumpMax = 0;
		int currJumpMax = 0;
		for (int i = 0; i < nums.length - 1; i++) {
			//currJumpMax = Math.max(currJumpMax, i + nums[i]);
			if ((i + nums[i]) > currJumpMax) {
				currJumpMax = i + nums[i];
			}
			if (i == prevJumpMax) {
				stepCount++;
				prevJumpMax = currJumpMax;
			}
		}
		return stepCount;
	}

	/**
	 *  Try to change this problem to a BFS problem,
	 *  where nodes in level i are all the nodes that can be reached in i-1th jump.
	 *  For example. 2 3 1 1 4 , is
	 		2||
	 		3 1||
	 		1 4 ||
	 *
	 */
	static int jump(int A[], int n) {
		if(n<2)return 0;
		int level = 0, currentMax = 0,i = 0,nextMax = 0;

		while (currentMax-i+1>0){		//nodes count of current level>0
			level++;
			for(;i<=currentMax;i++){	//traverse current level , and update the max reach of next level
				nextMax = Math.max(nextMax, A[i]+i);
				if(nextMax >= n-1)return level;   // if last element is in level+1,  then the min jump=level
			}
			currentMax=nextMax;
		}
		return 0;
	}

	/**
	 * eBay
	 *
	 * Given array of integers ranging from 1 < n < 10^5, find the max and min sum of n-1 elements.
	 * Example : int[] a = {4,1,2,3,5}
	 * Max : 14
	 * Min : 10
	 *
	 * Example : int[] a = {-4,-1,-2,-3,-5}
	 * Max : -10
	 * Min : -14
	 *
	 * Example : int[] a = {100000,100000,100000,100000,100000....n}, where n =100000
	 */

	static void findMinAndMax() {
		//int[] input = {4,1,2,3,5};
		//int[] input = {-4,-1,-2,-3,-5};
		// change types oto long only for this input, because the sum is going out of Integer range
		int[] input = getBigInput();

		long sum = 0;
		long max = Long.MIN_VALUE;
		long min = Long.MAX_VALUE;
		System.out.println("Integer Max : " + max);
		System.out.println("Integer Min : " + min);

		for (int i = 0; i < input.length; i++) {
			sum += input[i];
		}
		System.out.println("Total sum :: " + sum);

		for (int j = 0; j < input.length; j++) {
			long temp = sum - input[j];
			if (temp > max) {
				max = temp;
			}

			if (temp < min) {
				min = temp;
			}
		}
		System.out.println("Max :: " + max + ", Min :: " + min);
	}

	static int[] getBigInput() {
		int[] bigInput = new int[100000];
		for (int i = 0; i < 100000; i++) {
			bigInput[i] = 100000;
		}
		return bigInput;
	}
}
